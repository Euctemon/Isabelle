theory Generated_ideals
  imports "HOL-Algebra.Ideal"
begin


text \<open>First we define the set of left and right products. Then we define an ideal generated by a set A as a set of finite sums over @{term "gen_set R A"}\<close>

definition gen_set :: "_ \<Rightarrow> 'a set \<Rightarrow> 'a set"
  where "gen_set R A = {x \<otimes>\<^bsub>R\<^esub> a \<otimes>\<^bsub>R\<^esub> y | x y a. x \<in> carrier R \<and> y \<in> carrier R \<and> a \<in> A}"

locale gen_ideal = ring R for I and A and R (structure) +
  assumes genset_nonempty : "A \<noteq> {}"
    and subset_carrier : "A \<subseteq> carrier R"
    and carrier_ideal : "I = {\<Oplus>\<^bsub>R\<^esub> i\<in>{..n}. (f i) | (n::nat) f. f \<in> {..n} \<rightarrow> gen_set R A}"

begin


text \<open> The @{term "gen_set R A"} meets all ideal axioms but closure of addition.\<close>

lemma gen_set_carrier : "gen_set R A \<subseteq> carrier R"
proof
  fix x assume "x \<in> gen_set R A"
  then obtain r s a where "x = r \<otimes> a \<otimes> s" and "r \<in> carrier R" and "s \<in> carrier R" and "a \<in> A"
    unfolding gen_set_def by blast
  thus "x \<in> carrier R"
    using m_closed \<open>r \<in> carrier R\<close> \<open>s \<in> carrier R\<close> subset_carrier by blast
qed

lemma gen_set_zero_closed : "\<zero> \<in> gen_set R A"
proof -
  obtain a where "a \<in> A"
    using genset_nonempty by blast
  then have "\<zero> = \<zero> \<otimes> a \<otimes> \<zero>"
    using l_null r_null zero_closed subset_carrier by auto
  thus ?thesis
    unfolding gen_set_def using \<open>a \<in> A\<close> by blast
qed

lemma gen_set_self_closed : "A \<subseteq> gen_set R A"
proof
  fix a assume "a \<in> A"
  show "a \<in> gen_set R A"
  proof(cases "carrier R = {\<zero>}")
    case True
    then have "a = \<zero>"
      using \<open>a \<in> A\<close> subset_carrier by auto
    thus ?thesis
      using gen_set_zero_closed by simp
  next
    case False
    then have "a = \<one> \<otimes> a \<otimes> \<one>"
      by (metis \<open>a \<in> A\<close> l_one r_one subset_carrier subset_eq)
    thus ?thesis
      unfolding gen_set_def using \<open>a \<in> A\<close> by blast
  qed
qed

lemma gen_set_neg : assumes "x \<in> gen_set R A"
  shows "\<ominus>x \<in> gen_set R A"
proof -
  from assms obtain r s a where x_def : "x = r \<otimes> a \<otimes> s" and "r \<in> carrier R" and "s \<in> carrier R" and "a \<in> A"
    unfolding gen_set_def by blast
  then have mem : "\<ominus>r \<otimes> a \<otimes> s \<in> gen_set R A"
    unfolding gen_set_def by blast
  have neg_eq : "\<ominus>x = \<ominus>r \<otimes> a \<otimes> s"
    unfolding x_def using l_minus \<open>a \<in> A\<close> \<open>r \<in> carrier R\<close> \<open>s \<in> carrier R\<close> subset_carrier by auto
  thus ?thesis
    using mem neg_eq by auto
qed

lemma gen_set_rmul : assumes "x \<in> gen_set R A" and "y \<in> carrier R"
  shows "x \<otimes> y \<in> gen_set R A"
proof -
  from assms(1) obtain r s a where x_def : "x = r \<otimes> a \<otimes> s" and "r \<in> carrier R" and "s \<in> carrier R" and "a \<in> A"
    unfolding gen_set_def by blast
  have "s \<otimes> y \<in> carrier R"
    using \<open>s \<in> carrier R\<close> assms(2) by blast
  then have mem : "r \<otimes> a \<otimes> (s \<otimes> y) \<in> gen_set R A"
    unfolding gen_set_def using \<open>a \<in> A\<close> \<open>r \<in> carrier R\<close> by blast
  have "r \<otimes> a \<otimes> s \<otimes> y = r \<otimes> a \<otimes> (s \<otimes> y)"
    by (meson \<open>a \<in> A\<close> \<open>r \<in> carrier R\<close> \<open>s \<in> carrier R\<close> assms(2) m_assoc m_closed subsetD subset_carrier)
  thus ?thesis
    unfolding x_def using mem by auto
qed

lemma gen_set_lmul : assumes "x \<in> gen_set R A" and "y \<in> carrier R"
  shows "y \<otimes> x \<in> gen_set R A"
proof -
  from assms(1) obtain r s a where x_def : "x = r \<otimes> a \<otimes> s" and "r \<in> carrier R" and "s \<in> carrier R" and "a \<in> A"
    unfolding gen_set_def by blast
  have "y \<otimes> r \<in> carrier R"
    using \<open>r \<in> carrier R\<close> assms(2) by blast
  then have mem : "y \<otimes> r \<otimes> a \<otimes> s \<in> gen_set R A"
    unfolding gen_set_def using \<open>a \<in> A\<close> \<open>s \<in> carrier R\<close> by blast
  have "y \<otimes> r \<otimes> a \<otimes> s = y \<otimes> (r \<otimes> a \<otimes> s)"
    using \<open>a \<in> A\<close> \<open>r \<in> carrier R\<close> \<open>s \<in> carrier R\<close> assms(2) m_assoc subset_carrier by auto
  thus ?thesis
    unfolding x_def using mem by auto
qed


text \<open>We lift all properties of generating set to finite sums and prove that the set @{term I} is also closed under addition.\<close>

lemma ind_fun_carrier : assumes "f \<in> {..m::nat} \<rightarrow> gen_set R A"
  shows "f \<in> {..m} \<rightarrow> carrier R"
  using assms gen_set_carrier by auto

lemma ind_fun_carrier' : assumes "f \<in> {n::nat..m} \<rightarrow> gen_set R A"
  shows "f \<in> {n..m} \<rightarrow> carrier R"
  using assms gen_set_carrier by auto

lemma gen_set_singleton_lift : assumes "x \<in> gen_set R A"
  shows "x \<in> I"
proof -
  define f where "f = (\<lambda>i::nat. x)"
  then have mem : "f \<in> {..0} \<rightarrow> gen_set R A"
    using assms by blast
  then have "(\<Oplus> i\<in>{..0}. f i) \<in> I"
    using carrier_ideal by blast
  thus ?thesis
    using f_def finsum_0[of f] ind_fun_carrier[OF mem] by auto
qed

lemma gen_ideal_carr : "I \<subseteq> carrier R"
proof
  fix x assume "x \<in> I"
  then obtain n f where x_def : "x = (\<Oplus> i\<in>{..n::nat}. (f i))" and mem : "f \<in> {..n} \<rightarrow> gen_set R A"
    using carrier_ideal by blast
  show "x \<in> carrier R"
    unfolding x_def using ind_fun_carrier[OF mem] by simp
qed

lemma finsum_reindex_nat : assumes "f \<in> {..k::nat} \<rightarrow> gen_set R A"
  shows "(\<Oplus>i\<in>{..k}. (f i)) = (\<Oplus>i\<in>{r..r + k}. (f (i - r)))"
proof -
  have inj : "inj_on (\<lambda>i. i - r) {r..r + k}"
    using inj_on_diff_nat[of _ r] by force
  have "(\<lambda>i. i - r) ` {r..r + k} = {..k}"
  proof -
    have comp : "((\<lambda>i. i - r) \<circ> (\<lambda>i. i + r)) ` {..k::nat} = {..k}"
      by simp
    have "(\<lambda>i. i + r) ` {..k} = {r..r + k}"
      using atMost_atLeast0[of k] by auto
    thus ?thesis
      using comp image_comp[of "(\<lambda>i. i - r)" "(\<lambda>i. i + r)" "{..k}"] by argo
  qed
  thus ?thesis
    using add.finprod_reindex[of f, OF _ inj] assms ind_fun_carrier by presburger
qed

lemma gen_ideal_add : assumes "x \<in> I" and "y \<in> I"
  shows "x \<oplus> y \<in> I"
proof -
  obtain k f where x_def : "x = (\<Oplus>i\<in>{..k}. f i)" and f_def : "f \<in> {..k::nat} \<rightarrow> gen_set R A"
    using assms(1) carrier_ideal by blast
  obtain l g where y_def : "y = (\<Oplus>i\<in>{..l}. g i)" and g_def : "g \<in> {..l::nat} \<rightarrow> gen_set R A"
    using assms(2) carrier_ideal by blast
  have reindex : "y = (\<Oplus>i\<in>{Suc k.. Suc k + l}. g (i - Suc k))"
    using finsum_reindex_nat g_def y_def by blast
  define h where "h = (\<lambda> i. if i \<le> k then f i else g (i - Suc k))"
  have lower_k : "h \<in> {..k} \<rightarrow> gen_set R A"            (*to_k*)
    unfolding h_def using f_def by auto
  have upper_k : "h \<in> {Suc k..Suc k + l} \<rightarrow> gen_set R A"
    unfolding h_def using g_def by force
  have g_reindex : "(\<lambda>i. g (i - Suc k)) \<in> {Suc k..Suc k + l} \<rightarrow> carrier R"
  proof
    fix x assume "x \<in> {Suc k..Suc k + l}"
    then have "(x - Suc k) \<in> {..l}" by auto
    thus "g (x - Suc k) \<in> carrier R"
      using g_def
      using gen_set_carrier by auto
  qed
  have sum_eq : "x \<oplus> y = (\<Oplus>i\<in>{.. Suc k + l}. h i)"
  proof -
    have "x \<oplus> y = (\<Oplus>i\<in>{..k}. f i) \<oplus> (\<Oplus>i\<in>{Suc k.. Suc k + l}. g (i - Suc k))"
      using reindex x_def by blast
    also have "... = (\<Oplus>i\<in>{..k}. h i) \<oplus> (\<Oplus>i\<in>{Suc k.. Suc k + l}. g (i - Suc k))"
    proof -
      have "\<And>i. i \<in> {..k} \<Longrightarrow> f i = h i"
        using h_def by force
      thus ?thesis
        using finsum_cong'[of "{..k}" "{..k}" f h] ind_fun_carrier[OF f_def] by presburger
    qed
    also have "... = (\<Oplus>i\<in>{..k}. h i) \<oplus> (\<Oplus>i\<in>{Suc k.. Suc k + l}. h i)"
    proof -
      have "\<And>i. i \<in> {Suc k..Suc k + l} \<Longrightarrow> h i = g (i - Suc k)"
        using h_def by force
      thus ?thesis
        using finsum_cong'[OF _ g_reindex, of "{Suc k..Suc k + l}" h] by argo
    qed
    also have "... = (\<Oplus>i\<in>{.. Suc k + l}. h i)"
    proof -
      have "finite {..k}" and "finite {Suc k..Suc k + l}"
        by auto
      have range : "h \<in> {..k} \<rightarrow> carrier R \<and> h \<in> {Suc k.. Suc k + l} \<rightarrow> carrier R"
        using ind_fun_carrier ind_fun_carrier' lower_k upper_k by presburger
      have inter : "{..k} \<inter> {Suc k..Suc k + l}  = empty"
        by simp
      have union : "{..k} \<union> {Suc k..Suc k + l} = {..Suc k + l}"
        by force
      show ?thesis
        using finsum_Un_disjoint[OF \<open>finite {..k}\<close> \<open>finite {Suc k..Suc k + l}\<close> inter, of h] range union by argo
    qed
    finally show ?thesis
      by assumption
  qed
  have sum_in : "(\<Oplus>i\<in>{..Suc k + l}. h i) \<in> I"
  proof -
    have "{..Suc k + l} \<subseteq> {..k} \<union> {Suc k..Suc k + l}" by force
    then have "h \<in> {..Suc k + l} \<rightarrow> gen_set R A"
      using lower_k upper_k by auto
    thus ?thesis
      using carrier_ideal by blast
  qed
  thus ?thesis
    using sum_eq by argo
qed

lemma gen_ideal_neg : assumes "x \<in> I"
  shows "inv\<^bsub>add_monoid R\<^esub> x \<in> I"
proof -
  obtain k f where x_def : "x = (\<Oplus>i\<in>{..k}. f i)" and f_in : "f \<in> {..k::nat} \<rightarrow> gen_set R A"
    using assms carrier_ideal by blast
  have "x \<in> carrier R"
    using assms gen_ideal_carr by blast
  define g where "g = (\<lambda>i. \<ominus> f i)"
  have g_in : "g \<in> {..k} \<rightarrow> gen_set R A"
    using f_in funcsetI g_def gen_set_neg by blast
  then have neg_in : "(\<Oplus>i\<in>{..k}. g i) \<in> I"
    using carrier_ideal by blast
  then have neg_carr : "(\<Oplus>i\<in>{..k}. g i) \<in> carrier R"
    using gen_ideal_carr by blast
  have sum_zero : "\<And>i. i \<in> {..k} \<Longrightarrow> f i \<oplus> g i = \<zero>"
    using f_in g_def gen_set_carrier r_neg by auto
  then have "x \<oplus> (\<Oplus>i\<in>{..k}. g i) = \<zero>"
    unfolding x_def using finsum_addf[OF ind_fun_carrier[OF f_in] ind_fun_carrier[OF g_in]] 
      add.finprod_one_eqI[of "{..k}" "\<lambda>i. f i \<oplus> g i"] by argo
  thus ?thesis
    using add.comm_inv_char[OF \<open>x \<in> carrier R\<close> neg_carr] neg_in by argo
qed

lemma gen_ideal_lmul : assumes "x \<in> I" and "l \<in> carrier R"
  shows "l \<otimes> x \<in> I"
proof -
  obtain k f where x_def : "x = (\<Oplus>i\<in>{..k}. f i)" and f_in : "f \<in> {..k::nat} \<rightarrow> gen_set R A"
    using assms(1) carrier_ideal by blast
  have lmul : "l \<otimes> x = (\<Oplus>i\<in>{..k}. (l \<otimes> f i))"
    unfolding x_def using finsum_rdistr[OF _ _ ind_fun_carrier[OF f_in]] assms(2) by blast
  show ?thesis
  proof(simp add : lmul)
    have "\<And>i. i \<in> {..k} \<Longrightarrow> l \<otimes> f i \<in> gen_set R A"
      by (meson assms(2) f_in funcset_mem gen_set_lmul)
    thus "(\<Oplus>i\<in>{..k}. (l \<otimes> f i)) \<in> I"
      using carrier_ideal by blast
  qed
qed

lemma gen_ideal_rmul : assumes "x \<in> I" and "r \<in> carrier R"
  shows "x \<otimes> r \<in> I"
proof -
  obtain k f where x_def : "x = (\<Oplus>i\<in>{..k}. f i)" and f_in : "f \<in> {..k::nat} \<rightarrow> gen_set R A"
    using assms(1) carrier_ideal by blast
  have lmul : "x \<otimes> r = (\<Oplus>i\<in>{..k}. (f i \<otimes> r))"
    unfolding x_def using finsum_ldistr[OF _ _ ind_fun_carrier[OF f_in]] assms(2) by blast
  show ?thesis
  proof(simp add : lmul)
    have "\<And>i. i \<in> {..k} \<Longrightarrow> f i \<otimes> r \<in> gen_set R A"
      by (meson assms(2) f_in funcset_mem gen_set_rmul)
    thus "(\<Oplus>i\<in>{..k}. (f i \<otimes> r)) \<in> I"
      using carrier_ideal by blast
  qed
qed

lemma gen_ideal_subgroup : shows "subgroup I (add_monoid R)"
proof
  show "I \<subseteq> carrier (add_monoid R)"
    by (simp add: gen_ideal_carr)
  show "\<And>x y. x \<in> I \<Longrightarrow> y \<in> I \<Longrightarrow> x \<otimes>\<^bsub>add_monoid R\<^esub> y \<in> I"
    by (simp add: gen_ideal_add)
  show "\<one>\<^bsub>add_monoid R\<^esub> \<in> I" 
    by (simp add: gen_set_zero_closed gen_set_singleton_lift)
  show "\<And>x. x \<in> I \<Longrightarrow> inv\<^bsub>add_monoid R\<^esub> x \<in> I"
    by (simp add: gen_ideal_neg)
qed


text \<open>The @{term I} is an ideal in R and is equal to the @{term "Idl A"}.\<close>

lemma gen_ideal_ideal : "ideal I R"
proof(rule idealI, simp add: local.ring_axioms)
  show "subgroup I (add_monoid R)"
    using gen_ideal_subgroup by auto
  show "\<And>x r. x \<in> I \<Longrightarrow> r \<in> carrier R \<Longrightarrow> r \<otimes> x \<in> I"
    using gen_ideal_lmul by blast
  show "\<And>x r. x \<in> I \<Longrightarrow> r \<in> carrier R \<Longrightarrow> x \<otimes> r \<in> I"
    using gen_ideal_rmul by blast
qed

lemma gen_set_subset_Idl : "gen_set R A \<subseteq> Idl A"
proof
  fix x assume "x \<in> gen_set R A"
  then obtain r s a where x_def : "x = r \<otimes> a \<otimes> s" and r_in : "r \<in> carrier R" and s_in : "s \<in> carrier R" and "a \<in> A"
    using gen_set_def[of R A] by blast
  then have a_in : "a \<in> Idl A"
    using genideal_self subset_carrier by auto
  have ideal : "ideal (Idl A) R"
    by (simp add: genideal_ideal subset_carrier)
  show "x \<in> Idl A"
    unfolding x_def using ideal.I_l_closed[OF ideal a_in r_in] ideal.I_r_closed[OF ideal _ s_in] by auto
qed

lemma zero_Idl_closed : "\<zero> \<in> Idl A"
  using gen_set_subset_Idl gen_set_zero_closed by blast

lemma finsum_Idl_closed : assumes "finite B" and f : "f \<in> B \<rightarrow> Idl A"
  shows "(\<Oplus>i\<in>B. f i) \<in> Idl A"
  using f
proof(induct B rule: infinite_finite_induct)
  case (infinite B) show ?case
    using infinite.hyps zero_Idl_closed by auto
next
  case empty show ?case
    using zero_Idl_closed by auto
next
  case (insert b B)
  have idl : "ideal (Idl A) R"
    using genideal_ideal subset_carrier by auto
  have eq : "(\<Oplus> i\<in>(insert b B). f i) = f b \<oplus> (\<Oplus> i\<in>B. f i)"
  proof(rule finsum_insert, simp_all add : insert.hyps)
    show "f \<in> B \<rightarrow> carrier R"
      using ideal.Icarr[OF idl] insert.prems by blast
    show "f b \<in> carrier R"
      using ideal.Icarr[OF idl] insert.prems by blast
  qed
  have sum : "f b \<oplus> (\<Oplus>i\<in>B. f i) \<in> Idl A"
  proof(rule add.subgroupE(4))
    show "subgroup (Idl A) (add_monoid R)"
      using add.normal_inv_iff ideal_is_normal[OF idl] by blast
    show "f b \<in> Idl A"
      using insert.prems by auto
    show "(\<Oplus> i\<in>B. f i) \<in> Idl A"
      using insert.hyps(3) insert.prems by auto
  qed
  show ?case
    using eq sum by argo
qed

lemma gen_ideal_genideal : "I = Idl A"
proof
  show "I \<subseteq> Idl A"
  proof
    fix x assume "x \<in> I"
    then obtain k f where x_def : "x = (\<Oplus>i\<in>{..k::nat}. f i)" and "f \<in> {..k} \<rightarrow> gen_set R A"
      using carrier_ideal by blast
    then have "f \<in> {..k} \<rightarrow> Idl A"
      using gen_set_subset_Idl by auto
    thus "x \<in> Idl A"
      by (simp add: finsum_Idl_closed x_def)
  qed
  show "Idl A \<subseteq> I"
  proof(rule genideal_minimal, simp add : gen_ideal_ideal)
    show "A \<subseteq> I"
      using gen_set_self_closed gen_set_singleton_lift by auto
  qed
qed

end
end